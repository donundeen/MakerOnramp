<script>
class MilestoneManager {
    constructor() {
        this.milestones = [];
        this.skillTrees = [];
        this.skillTreeItems = {};
        this.currentMilestone = null;
        this.requirementEditorTemplate = null;
        this.reloadCallback = null;
    }

    setReloadCallback(callback){
        this.reloadCallback = callback;
    }

    triggerReload(){
        if(this.reloadCallback){
            this.reloadCallback();
        }
    }

    load() {
        return new Promise((resolve, reject) => {
            this.loadSkillTrees()
            .then(() => this.loadAllSkillTreeItems())
            .then(() => this.loadMilestones()) 
            .then(resolve)  // this line is getting called before the milestones are loaded
            .catch(reject);
        });
    }

    loadSkillTrees(){
        // for each skill tree name, load the skill tree items,
        // make sure all the skill tree items are loaded before resolving
        console.log("loading skill trees", this.skillTrees);
        return new Promise((resolve, reject) => {

            if(localStorage.allSkillTreeSheetNames && localStorage.allSkillTreeSheetNames.length > 0){
                console.log("using local storage for skill trees");
                this.skillTrees = JSON.parse(localStorage.allSkillTreeSheetNames);
                console.log("skillTrees", this.skillTrees);
                resolve(this.skillTrees);
            }else{
                console.log("getting skill trees from server");
                google.script.run.withSuccessHandler(result => {
                    this.skillTrees = result;
                    localStorage.allSkillTreeSheetNames = JSON.stringify(result);
                    resolve(this.skillTrees);
                }).getAllSkillTreeSheetNames();
            }
        });

    }

    loadAllSkillTreeItems(){
        console.log("loading all skill tree items");
        console.log("skillTrees", this.skillTrees);
        let self = this;
        return new Promise((resolve, reject) => {
            let promises = [];
            self.skillTrees.forEach(skillTree => {
                promises.push(self.loadSkillTreeItems(skillTree));
            });
            Promise.all(promises).then(resolve).catch(reject);
        });
    }

    loadSkillTreeItems(skillTreeName){
        console.log("loading skill tree items for " + skillTreeName);
        let self = this;

        return new Promise((resolve, reject) => {
            console.log("SkillTreeItemList loading sheetName: ", skillTreeName);
            if(localStorage["allSkillTreeRows"+skillTreeName]){
                console.log("SkillTreeItemList using local storage");
                self.skillTreeItems[skillTreeName] = JSON.parse(localStorage["allSkillTreeRows"+skillTreeName]);
                resolve(self.skillTreeItems[skillTreeName]);
            }else{
                console.log("getting all skill tree rows from server");
                google.script.run.withSuccessHandler(function(result) {
                    console.log(" got result from server for sheetName:" , skillTreeName, result);
                    self.skillTreeItems[skillTreeName] = result.data;
                    localStorage["allSkillTreeRows"+skillTreeName] = JSON.stringify(self.skillTreeItems[skillTreeName]);
                    resolve(self.skillTreeItems[skillTreeName]);
                }).getAllSkillTreeRows(skillTreeName);
            }
        });
    }

    loadMilestones(){
        console.log("loading milestones");
        console.log(this.skillTreeItems);
        return new Promise((resolve, reject) => {
            google.script.run.withSuccessHandler(result => {
                console.log("milestones", result);
                this.milestones = result;
                resolve(this.milestones);
            }).getMilestonesForStudent('all');
        });
    }


    initializeEventListeners() {
        this.requirementsList = document.getElementById('requirementsList');
        this.form = document.getElementById('milestoneForm');        
        this.modal = document.getElementById('milestoneEditorModal');

        // Create new milestone button
        document.getElementById('createMilestoneBtn').addEventListener('click', () => {
            this.openEditor();
        });

        // Add requirement button
        document.getElementById('addRequirementBtn').addEventListener('click', () => {
            this.addRequirement();
        });

        // Form submission
        this.form.addEventListener('submit', (e) => {
            e.preventDefault();
            this.saveMilestone();
        });

        // Close modal
        document.querySelector('.btn-close').addEventListener('click', () => {
            this.closeModal();
        });

        document.getElementById('cancelEditBtn').addEventListener('click', () => {
            this.closeModal();
        });

        // Edit and delete buttons
        document.addEventListener('click', (e) => {
            if (e.target.classList.contains('btn-edit')) {
                const milestoneId = e.target.dataset.milestoneId;
                this.editMilestone(milestoneId);
            } else if (e.target.classList.contains('btn-delete')) {
                const milestoneId = e.target.dataset.milestoneId;
                this.deleteMilestone(milestoneId);
            }
        });

        // Requirement type change
        this.requirementsList.addEventListener('change', (e) => {
            if (e.target.classList.contains('requirement-type')) {
                this.updateRequirementType(e.target);
            }
        });

        // Add item button
        this.requirementsList.addEventListener('click', (e) => {
            if (e.target.classList.contains('btn-add-item')) {
                this.addItem(e.target.closest('.requirement-editor'));
            }
        });

        // Remove requirement/item buttons
        this.requirementsList.addEventListener('click', (e) => {
            if (e.target.classList.contains('btn-remove-requirement')) {
                e.target.closest('.requirement-editor').remove();
            } else if (e.target.classList.contains('btn-remove-item')) {
                e.target.closest('.item-editor').remove();
            }
        });

        // Skill tree selection change
        this.requirementsList.addEventListener('change', (e) => {
            if (e.target.classList.contains('skill-tree-select')) {
                this.updateSkillTreeItems(e.target);
            }
        });
    }



    display(milestoneManagerTemplate, requirementEditorTemplate, requirementItemEditorTemplate, contentBodyTargetID){
        this.requirementEditorTemplate = requirementEditorTemplate;
        this.requirementItemEditorTemplate = requirementItemEditorTemplate;
        let html = milestoneManagerTemplate(this);
        $(contentBodyTargetID).html(html);
        this.renderMilestones();
    }

    renderMilestones() {
        /*
        const template = document.getElementById('template-milestone-manager').innerHTML;
        const html = Mustache.render(template, { milestones: this.milestones });
        document.querySelector('.milestone-manager').innerHTML = html;
        */
        this.initializeEventListeners();

    }

    openEditor(milestone = null) {
        console.log("openEditor called, skillTrees:", this.skillTrees);
        this.currentMilestone = milestone;
        this.form = document.getElementById('milestoneForm');        
        this.requirementsList = document.getElementById('requirementsList');

        this.form.reset();
        
        if (milestone) {
            document.getElementById('milestoneName').value = milestone.name;
            document.getElementById('milestoneDescription').value = milestone.description;
            this.renderRequirements(milestone.requirements);
        } else {
            this.requirementsList.innerHTML = '';
        }
        
        this.modal.style.display = 'block';
    }

    renderRequirements(requirements) {
        console.log("renderRequirements called with:", requirements);
        console.log("this.skillTrees:", this.skillTrees);
        this.requirementsList = document.getElementById('requirementsList');
        this.requirementsList.innerHTML = '';
        const template = this.requirementEditorTemplate;
        
        requirements.forEach(req => {
            console.log("Processing requirement:", req);
            // Create the context for the requirement
            const context = {
                id: req.id,
                type: req.type,
                required: req.required,
                skillTrees: this.skillTrees.map(treeName => ({
                    name: treeName,
                    selected: treeName === req.skillTreeName
                })),
                items: req.items ? req.items.map(item => ({
                    skillTreeItemID: item.skillTreeItemID,
                    skillTreeName: item.skillTreeName,
                    name: item.name,
                    skillTrees: this.skillTrees.map(treeName => ({
                        name: treeName,
                        selected: treeName === item.skillTreeName
                    })),
                    skillTreeItems: this.skillTreeItems[item.skillTreeName]?.map(skillItem => ({
                        SkillTreeItemID: skillItem.SkillTreeItemID,
                        Title: skillItem.Title,
                        selected: skillItem.SkillTreeItemID === item.skillTreeItemID
                    })) || []
                })) : []
            };
            
            console.log("Context for template:", context);
            let handlebarsTemplate = template;
            const html = handlebarsTemplate(context);
            this.requirementsList.insertAdjacentHTML('beforeend', html);
        });
    }

    addRequirement() {
        console.log("adding requirement");
        this.requirementsList = document.getElementById('requirementsList');
        const template = this.requirementEditorTemplate;
        
        // Safety check for skillTrees
        if (!this.skillTrees || !Array.isArray(this.skillTrees)) {
            console.error("skillTrees is not valid:", this.skillTrees);
            return;
        }
        
        const context = {
            id: 'req_' + Date.now(),
            type: 'AND',
            required: undefined,
            items: [],
            skillTrees: this.skillTrees.map(tree => {
                // Handle both string and object formats
                const treeName = typeof tree === 'string' ? tree : (tree.name || tree);
                return {
                    name: treeName,
                    selected: false
                };
            })
        };
        
        console.log("Context for addRequirement:", context);
        let handlebarsTemplate = template;
        const html = handlebarsTemplate(context);
        //        const html = Mustache.render(template, context);
        this.requirementsList.insertAdjacentHTML('beforeend', html);
    }

    addItem(requirementEditor) {
        console.log("adding item", this.skillTreeItems);
        console.log("adding item", this.skillTrees);
        const itemsList = requirementEditor.querySelector('.items-list');
        const template = this.requirementItemEditorTemplate;
        const context = {
            skillTreeItemID: '',
            skillTreeName: '',
            name: '',
            skillTrees: this.skillTrees.map(tree => {
                // Handle both string and object formats
                const treeName = typeof tree === 'string' ? tree : (tree.name || tree);
                return {
                    name: treeName,
                    selected: false
                };
            }),
            skillTreeItems: []
        };
        let handlebarsTemplate = template;
        const html = handlebarsTemplate(context);
       // const html = Mustache.render(template, context);
        itemsList.insertAdjacentHTML('beforeend', html);
    }

    updateRequirementType(select) {
        const requirementEditor = select.closest('.requirement-editor');
        const countInput = requirementEditor.querySelector('.requirement-count-input');
        
        if (select.value === 'OR' || select.value === 'COUNT') {
            countInput.style.display = 'flex';
        } else {
            countInput.style.display = 'none';
        }
    }

    updateSkillTreeItems(select) {
        const itemEditor = select.closest('.item-editor');
        const skillTreeName = select.value;
        const skillTreeItemSelect = itemEditor.querySelector('.skill-item-select');
        if(skillTreeName && this.skillTreeItems[skillTreeName]){
            this.updateSkillTreeItemOptions(skillTreeItemSelect,  this.skillTreeItems[skillTreeName]);
        }

    }

    updateSkillTreeItemOptions(select, items) {
        console.log("updating skill tree item options", items);
        select.innerHTML = items.map(item => 
            `<option value="${item.SkillTreeItemID}">${item.Title}</option>`
        ).join('');
        console.log("updated skill tree item options", select.innerHTML);
    }

    saveMilestone() {
        this.form = document.getElementById('milestoneForm');        
        const formData = new FormData(this.form);
        const milestoneData = {
            id: this.currentMilestone?.id || 'milestone_' + Date.now(),
            name: formData.get('name'),
            description: formData.get('description'),
            requirements: this.getRequirementsData()
        };

        try {
            if (this.currentMilestone) {
                google.script.run.withSuccessHandler(() => {
                    this.closeModal();
                    this.triggerReload();

                }).updateMilestone(milestoneData);
            } else {
                google.script.run.withSuccessHandler(() => {
                    this.closeModal();
                    this.triggerReload();
                }).createMilestone(milestoneData);
            }
        } catch (error) {
            console.error('Error saving milestone:', error);
        }
    }

    getRequirementsData() {
        const requirements = [];
        console.log("getting requirements data");
        this.requirementsList = document.getElementById('requirementsList');
        console.log("this.requirementsList", this.requirementsList);
        this.requirementsList.querySelectorAll('.requirement-editor').forEach(editor => {
            console.log("editor", editor);
            const type = editor.querySelector('.requirement-type').value;
            const required = type === 'OR' || type === 'COUNT' 
                ? parseInt(editor.querySelector('.requirement-count-input input').value)
                : undefined;
            
            const items = [];
            editor.querySelectorAll('.item-editor').forEach(itemEditor => {
                console.log("itemEditor", itemEditor);
                const skillTreeName = itemEditor.querySelector('.skill-tree-select').value;
                const skillTreeItemID = itemEditor.querySelector('.skill-item-select').value;
                console.log("skillTreeName", skillTreeName);
                console.log("skillTreeItemID", skillTreeItemID);
                console.log("this.skillTreeItems", this.skillTreeItems[skillTreeName]);
                const item = this.skillTreeItems[skillTreeName].find(i => i.SkillTreeItemID === skillTreeItemID);
                console.log("item", item);
                if(item){
                    items.push({
                        skillTreeName,
                        skillTreeItemID,
                        name: item.Title
                    });
                }else{
                    console.log("item not found", skillTreeName, skillTreeItemID);
                }
            });

            requirements.push({
                id: editor.dataset.requirementId,
                type,
                required,
                items
            });
        });

        return requirements;
    }

    deleteMilestone(milestoneId) {
        if (confirm('Are you sure you want to delete this milestone?')) {
            try {
                google.script.run.withSuccessHandler(() => {
                    this.load();
                }).deleteMilestone(milestoneId);
            } catch (error) {
                console.error('Error deleting milestone:', error);
            }
        }
    }

    editMilestone(milestoneId) {
        const milestone = this.milestones.find(m => m.id === milestoneId);
        if (milestone) {
            this.openEditor(milestone);
        } else {
            console.error('Milestone not found:', milestoneId);
        }
    }

    closeModal() {
        this.form = document.getElementById('milestoneForm');        
        this.modal = document.getElementById('milestoneEditorModal');
        this.requirementsList = document.getElementById('requirementsList');

        this.modal.style.display = 'none';
        this.currentMilestone = null;
        this.form.reset();
        this.requirementsList.innerHTML = '';
    }
}
</script>
